#!/bin/zsh

# * Only allow '[' after key or after indent; in general, when there is a '[]'
#   expression, there will only be one element in `values`
# * If a line begins with a quote and doesn't end with one, then treat the next
#   line as a continuation. Consider whether or not to check for '@'s and ':'s
#   when checking for quotes
# * Update comments

# {{{1 _build_index_rg()

_build_index_rg() {
    if [[ $3 ]]; then
        if [[ $1 == '-c' ]]; then
            echo $3 | rg --only-matching $1 $2
        else
            echo $3 | rg --only-matching $1 --replace $2
        fi
    else
        echo $2 | rg --only-matching $1
    fi
}

# {{{1 _build_index_get()

declare -A blocks

_build_index_get() {
    # {{{2 Get YAML block from file and store in array (only one block allowed)

    if [[ $blocks[$2] ]]; then
        block=( ${(s,:,)$blocks[$2]} )
    else
        local -a line_numbers
        line_numbers=( ${(f)"$(rg --line-number '^---$' $2 | cut -d : -f 1)"} )

        if (( $#line_numbers < 2 )); then
            echo 'build-index: cannot get YAML block for' $2 >&2
            return 1
        fi

        local -i block_end=$(( line_numbers[2] - 1 ))
        local -i block_length=$(( line_numbers[2] - line_numbers[1] - 1 ))
        declare -ga block
        block=( ${(f)"$(cat $2 | head -$block_end | tail -$block_length)"} )
    fi

    # {{{2 Get values from YAML metadata block

    local -i first_line_num=$block[(i)$1:*]
    local -a block_slice=( $block[$first_line_num,-1] )

    # Define search patterns for lines that contain an (unindented) key/value
    # pair, lines that start with a dash, and lines that start with
    # indentation.
    local kv_regex='^[^-:\s]+[^:]*:\s*(.*)$'
    local kv_regex_posix=${kv_regex/\\s/[:space:]}
    kv_regex_posix=${${kv_regex_posix//\\s/[[:space:]]}//[\(\)]/}
    local dash_regex='^\s*(-\s+(.+))$'
    local dash_regex_posix=${${dash_regex//\\s/[[:space:]]}//[\(\)]/}
    local indent_regex='^\s+([^-].*)$'
    local indent_regex_posix=${${indent_regex//\\s/[[:space:]]}//[\(\)]/}

    local -a values
    local value

    # Define flags:
    # * If `string` is equal to 1, then `value` is treated as a continuation of
    #   previous values corresponding to the same key (i.e., as a continuation
    #   of `metadata[$key]`).
    # * If `list` is equal to 1, then `value` is treated as a continuation of
    #   the most recent item in a list (i.e., as a continuation of the last
    #   member of a comma-separated list to which `metadata[$key]` expands).
    local -i cont=0
    local -i switch=0

    local line
    for line in $block_slice; do
        if [[ $line =~ $kv_regex_posix ]]; then
            if (( switch == 0 )); then
                values=( "$(_build_index_rg $kv_regex '$1' $line)" )

                # If there is a value on the same line as the key, subsequent
                # lines might be treated as a continuation of that value; so
                # set `string` to 1.
                [[ $values[-1] ]] && cont=1
                switch=1
            else
                break
            fi

        elif [[ $line =~ $dash_regex_posix ]]; then

            if (( cont == 0 )); then
                if [[ $1 == title ]]; then
                    unset values
                    return 1
                else
                    value="$(_build_index_rg $dash_regex '$2' $line)"
                    values+=( $value )
                fi
            else
                value="$(_build_index_rg $dash_regex '$1' $line)"
                values[-1]="$values[-1] $value"
            fi

        elif [[ $line =~ $indent_regex_posix ]]; then
            value="$(_build_index_rg $indent_regex '$1' $line)"

            if [[ $values[-1] ]]; then
                values[-1]="$values[-1] $value"
            else
                values[-1]=$value
            fi

            # Following an indented line, subsequent indented lines might be
            # treated as a continuation of `value`; so set string to 1.
            cont=1

        else
            unset values
            return 1
        fi
    done

    # {{{2 Process metadata values

    if [[ ! $values ]]; then
        echo 'build-index: no value found for key' $1 'in' $2 >&2
        return 1
    fi

    if [[ ${values[1][1]} == '[' ]]; then
        if [[ $1 = 'title' ]]; then
            unset values
            return 1
        else
            values=( ${(s:, :)${${values#'['}%']'}} )
        fi
    elif [[ $1 == 'keywords' ]]; then
        values=( ${(s:, :)${(j:, :)values}} )
    fi

    # Maybe get rid of quotes at the beginning or end of arrays, or the
    # beginning or end of array elements
    local -i i=1
    for value in $values; do
        # If entire value is quoted, strip off surrounding quotes; otherwise,
        # check for colons or '@' (which would be allowed if the entire value
        # is quoted)

        if [[ $value =~ '^''.*''[[:space:]]*$' ]]; then
            # Remove surrounding quotes from value. Substitute escaped interior
            # quotes (`''`) with just one single quote. No need to deal with
            # any backslashes, because they will not be printed by `print` at
            # the end.
            value=${${${value#\'}%\'}:gs/\'\'/\'}
            values[$i]=$value

        elif [[ $value =~ '^".*"[[:space:]]*$' ]]; then
            # Remove surrounding quotes from value
            value=${${value#\"}%\"}
            values[$i]=$value

        else
            # Throw out nested key/value pairs (whether legal or illegal by
            # YAML parsing rules; I don't use nested key/value pairs right now,
            # so this script does not parse them)
            if [[ $value =~ ':' ]]; then
                echo 'build-index: value in' $2 'contains nested mapping' >&2
                unset "values[$i]"
            fi

            # Throw out values that start with '@'; YAML will refuse to parse
            # these.
            if [[ $value =~ '^@' ]]; then
                echo 'build-index: value in' $2 'begins with ''@''' >&2
                unset values
                return 1
            fi
        fi

        (( i = i + 1 ))
    done

    if [[ ! $values ]]; then
        echo 'build-index: no value found for key' $1 >&2
        return 1
    fi

    # }}}2

    print -l $values
}

# {{{1 Build an index file for every keyword found in notes

cd $HOME/Documents/Notes || exit 1

setopt extended_glob

declare -T keywords_scalar keywords_array
declare -Ua all_keywords
declare -A keywords
declare -T block_scalar block

declare file
for file in *.md; do
    keywords_array=( ${(f)"$(_build_index_get keywords $file)"} )
    all_keywords+=( $keywords_array )
    keywords[$file]=$keywords_scalar
    blocks[$file]=$block_scalar
done

declare index_file
declare -a files
declare title
declare link

declare keyword
for keyword in $all_keywords; do
    index_file=${keyword:gs/ /_}_index.md

    if [[ -f $index_file ]]; then
        block=( '\-\-\-' ${(s.:.)$blocks[$index_file]} '\-\-\-\n' )
    else
        block=(
            '\-\-\-'
            'id: '${index_file%.md}
            'title: '$keyword
            'keywords: '
            '\-\-\-\n'
        )
    fi

    print -l $block > $index_file

    files=( ${(k)keywords[(R)(*$keyword:*)|(*:$keyword*)]} )

    for file in $files; do
        title="$(_build_index_get title $file)"
        link='['$title']['$file']'
        echo $link
    done | sort --ignore-case >> $index_file
done

# }}}1
