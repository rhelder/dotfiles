#!/bin/zsh

# * Rewrite to parse lines on the basis of their indentation
# * Update comments
# * Add errors for missing argumens
# * Compose error messages
# Current draft takes 0.600 s to run

# {{{1 _build_index_rg()

_build_index_rg() {
    if [[ $3 ]]; then
        if [[ $1 == '-c' ]]; then
            echo $3 | rg --only-matching $1 $2
        else
            echo $3 | rg --only-matching $1 --replace $2
        fi
    else
        echo $2 | rg --only-matching $1
    fi
}

# {{{1 _build_index_get_block()

declare -A blocks

_build_index_get_block() {

    if [[ $blocks[$1] ]]; then
        block=( ${(s,:,)$blocks[$1]} )
    else
        local -a line_numbers
        line_numbers=( ${(f)"$(rg --line-number '^---$' $1 | cut -d : -f 1)"} )

        if (( $#line_numbers < 2 )); then
            echo 'build-index: cannot get YAML block for' $1 >&2
            return 1
        fi

        local -i block_end=$(( line_numbers[2] - 1 ))
        local -i block_length=$(( line_numbers[2] - line_numbers[1] - 1 ))
        local -a block
        block=( ${(f)"$(cat $1 | head -$block_end | tail -$block_length)"} )
        blocks[$1]=${(j:+:)block}
    fi
}

# {{{1 _build_index_get()

_build_index_get() {
    # {{{2 Get values from YAML metadata block

    local -a block=( ${(s:+:)blocks[$2]} )
    local -i first_line_num=$block[(i)$1:*]
    local -a block_slice=( $block[$first_line_num,-1] )

    # Define search patterns for lines that contain an (unindented) key/value
    # pair, lines that start with a dash, and lines that start with
    # indentation.
    local kv_regex='^[^-:\s]+[^:]*:\s*(.*?)\s*$'
    local kv_regex_posix=${kv_regex/\\s/[:space:]}
    kv_regex_posix=${kv_regex_posix//\\s/[[:space:]]}
    kv_regex_posix=${kv_regex_posix//\?/}
    local dash_regex='^\s*(-\s+(-\s+)*(.+?))\s*$'
    local dash_regex_posix=${dash_regex//\\s/[[:space:]]}
    dash_regex_posix=${dash_regex_posix//\?/}
    local indent_regex='^\s+([^-].*?)\s*$'
    local indent_regex_posix=${indent_regex//\\s/[[:space:]]}
    indent_regex_posix=${indent_regex_posix//\?/}

    local -a values
    local value

    # Define flags:
    # * If `string` is equal to 1, then `value` is treated as a continuation of
    #   previous values corresponding to the same key (i.e., as a continuation
    #   of `metadata[$key]`).
    # * If `list` is equal to 1, then `value` is treated as a continuation of
    #   the most recent item in a list (i.e., as a continuation of the last
    #   member of a comma-separated list to which `metadata[$key]` expands).
    local -i bracket=0
    local -i cont=0
    local -i switch=0

    local line
    for line in $block_slice; do
        if [[ $line =~ $kv_regex_posix ]]; then
            if (( switch == 0 )); then
                value="$(_build_index_rg $kv_regex '$1' $line)"

                [[ $value[1] == '[' ]] && bracket=1
                if (( bracket == 1 )); then
                    if [[ $value[-1] == ']' ]]; then
                        bracket=2
                    elif [[ $value =~ ']' ]]; then
                        echo 'build-index: values after bracketed list' >&2
                        unset values
                        return 1
                    fi
                fi

                values+=( $value )

                # If there is a value on the same line as the key, subsequent
                # lines might be treated as a continuation of that value; so
                # set `string` to 1.
                [[ $values ]] && cont=1
                switch=1
            else
                if (( bracket == 1 )); then
                    echo 'build-index: closing bracket not found' >&2
                    unset values
                    return 1
                fi

                break
            fi

        elif (( bracket == 2 )); then
            echo 'build-index: values after bracketed list' >&2
            unset values
            return 1

        elif [[ $line =~ $dash_regex_posix ]]; then
            if (( cont == 0 )); then
                if [[ $1 == title ]]; then
                    echo 'list in title' >&2
                    unset values
                    return 1

                else
                    value="$(_build_index_rg $dash_regex '$3' $line)"

                    if [[ $value[1] == '[' ]]; then
                        echo 'build-index: list within list' >&2
                        unset values
                        return 1

                    else
                        values+=( $value )
                    fi
                fi

            else
                value="$(_build_index_rg $dash_regex '$1' $line)"

                [[ $value[-1] == ']' ]] && bracket=2

                values[-1]="$values[-1] $value"
            fi

        elif [[ $line =~ $indent_regex_posix ]]; then
            value="$(_build_index_rg $indent_regex '$1' $line)"

            [[ $value[1] == '[' ]] && bracket=1
            if (( bracket == 1 )); then
                if [[ $value[-1] == ']' ]]; then
                    bracket=2
                elif [[ $value =~ ']' ]]; then
                    echo 'build-index: values after bracketed list' >&2
                    unset values
                    return 1
                fi
            fi

            if [[ $values[-1] ]]; then
                values[-1]="$values[-1] $value"
            else
                values[-1]=$value
            fi

            # Following an indented line, subsequent indented lines might be
            # treated as a continuation of `value`; so set string to 1.
            cont=1

        else
            unset values
            return 1
        fi
    done

    # {{{2 Process metadata values

    if [[ ! $values ]]; then
        echo 'build-index: no value found for key' $1 'in' $2 >&2
        return 1
    fi

    if (( bracket == 2 )); then
        if [[ $1 == 'title' ]]; then
            echo 'Not allowed' >&2
            unset values
            return 1
        else
            values=( ${(s:,:)${${values#'['}%']'}} )
        fi
    fi

    local -i start
    local -i single_quote=0
    local -i double_quote=0
    local -i index=1
    local -i next=1
    local quote="'"
    local dquote='"'

    for value in $values; do
        value=${${value##[[:space:]]#}%%[[:space:]]#}
        values[$index]=$value

        if (( bracket == 2 )); then
            if [[ $value[1] == '-' ]]; then
                echo 'No dash allowed' >&2
                unset values
                return 1
            fi
        fi

        if (( single_quote == 0 )); then
            if [[ $value[1] == "'" && ! $double_quote -eq 1 ]]; then
                value=${value#\'}
                start=$index
                single_quote=1
            else
                value=${value//\'/++}
                values[$index]=$value
            fi
        fi

        if (( double_quote == 0 )); then
            if [[ $value[1] == '"' && ! $single_quote -eq 1 ]]; then
                value=${value#\"}
                start=$index
                double_quote=1
            else
                value=${value//\"/\=\=}
                values[$index]=$value
            fi
        fi

        if (( single_quote == 0 && double_quote == 0 )); then
            if [[ $value =~ '^@' ]]; then
                echo 'build-index: value in' $2 'begins with ''@''' >&2
                unset values
                return 1
            elif [[ $value =~ ':' ]]; then
                echo 'build-index: value in' $2 'contains nested mapping' >&2
                unset values
                return 1
            fi
        fi

        if (( single_quote == 1 )); then
            next=${values[(ib:index:)*$quote*]}
            if (( index != next )); then
                index=$(( index + 1 ))
                continue
            fi

            value=${value//\\\'/++}
            value=${value//\'\'/++}

            if [[ $value[-1] == "'" ]]; then
                value=${value%\'}
                single_quote=0
            fi

            if (( index == start )); then
                values[$index]=$value
            else
                unset "values[$index]"
                values[$index-1]="$values[$index-1] $value"
            fi

        elif (( double_quote == 1 )); then
            next=${values[(ib:index:)*${dquote}*]}
            if (( index != next )); then
                index=$(( index + 1 ))
                continue
            fi

            value=${value//\\\"/\=\=}

            if [[ $value[-1] == '"' ]]; then
                value=${value%\"}
                double_quote=0
            fi

            if (( index == start )); then
                values[$index]=$value
            else
                unset "values[$index]"
                values[$index-1]="$values[$index-1] $value"
            fi
        fi

        index=$(( index + 1 ))
    done

    if (( single_quote == 1 )); then
        echo 'build-index: ending quote not found' >&2
        return 1
    elif (( ${values[(i)*$quote*]} <= $#values )); then
        echo 'build-index: unescaped single quotes found' >&2
        return 1
    elif (( double_quote == 1 )); then
        echo 'build-index: ending quote not found' >&2
        return 1
    elif (( "${values[(i)*${dquote}*]}" <= $#values )); then
        echo 'build-index: unescaped double quotes found' >&2
        return 1
    else
        values=( ${values//++/\'} )
        values=( ${values//\=\=/\"} )
    fi

    if [[ $1 == 'keywords' ]]; then
        values=( ${(s:,:)${(j:,:)values}} )
        index=1
        for value in $values; do
            value=${${value##[[:space:]]#}%%[[:space:]]#}
            values[$index]=$value
            index=$(( index + 1 ))
        done
    fi

    # }}}2

    print -l -- ${values//[[:space:]]##/ }
}

# {{{1 Build an index file for every keyword found in notes

cd $HOME/Documents/Notes || exit 1

setopt extended_glob

declare -T keywords_scalar keywords_array
declare -Ua all_keywords
declare -A keywords

declare file

for file in *.md; do
    _build_index_get_block $file
    keywords_array=( ${(f)"$(_build_index_get keywords $file)"} )
    all_keywords+=( $keywords_array )
    keywords[$file]=$keywords_scalar
done

declare index_file
declare -a files
declare title
declare link

declare keyword
for keyword in $all_keywords; do
    index_file=${keyword:gs/ /_}_index.md

    if [[ -f $index_file ]]; then
        block=( '\-\-\-' ${(s:+:)blocks[$index_file]} '\-\-\-\n' )
    else
        block=(
            '\-\-\-'
            'id: '${index_file%.md}
            'title: '$keyword
            'keywords: '
            '\-\-\-\n'
        )
    fi

    print -l $block > $index_file

    files=( ${(k)keywords[(R)(*$keyword:*)|(*:$keyword*)|($keyword)]} )

    for file in $files; do
        title="$(_build_index_get title $file)"
        link='['$title']['$file']'
        echo $link
    done | sort --ignore-case >> $index_file
done

# }}}1
