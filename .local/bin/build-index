#!/bin/zsh

# {{{1 Utility functions for `_get_block()`

__get_lines() {
    # Takes an array of line numbers as its argument. Eliminate all line
    # numbers prior to the possible beginning of a YAML block. It's possible
    # for a `...` line to appear in the document before the YAML block does.
    # So, if the first parameter is the line number of a `...` line, remove
    # that parameter from the array. Repeat until the first parameter is the
    # line number of a `---` line. If the `---` line is followed by a blank
    # line, it cannot be initiating a valid YAML block, so remove its line
    # number from the array. Finally, if the `---` is not the first line of the
    # document and is not preceded by a blank line, it cannot be initiating a
    # valid YAML block, so remove its line number from the array.
    while [[
        ! $file[$1] == ---[[:space:]]# ||
        $file[$1+1] == [[:space:]]# ||
        (! $1 -eq 1 && ! $file[$1-1] == [[:space:]]#)
    ]]; do
        shift
        # If there are less than two parameters left, then there is no valid
        # YAML block in this document
        if (( $# < 2 )); then
            return 1
        fi
    done

    print -l $*
}

__check_lines() {
    # Takes an array of line numbers as its argument. Determine whether or not
    # line `$1` really is the beginning of a YAML block. If line `$2` is a
    # `...` line, then the lines between line `$1` and line `$2` will be
    # treated as a YAML block by Pandoc. Otherwise, the lines will only be
    # treated as a YAML block by Pandoc if the line after line `$1` contains a
    # key. If neither of these conditions is met, remove the first parameter
    # from the array.
    if  [[
        ! $file[$2] == ...[[:space:]]# &&
        ! $file[$1+1] == [[:space:]]#[^-]##:*
    ]]; then
        shift
        print -l $*
        return 1
    else
        print -l $*
        return 0
    fi
}

# {{{1 _get_block()

_get_block() {
    # Store contents of file in array; this will make is easier to get lines by
    # line number
    local -a file=( "${(@f)$(cat $1)}" )

    # Scan the document for all lines that might validly open or close a YAML
    # block, and store line numbers in an array
    local -a line_numbers=(
        ${(f)"$(rg --line-number '^(---|\.\.\.)\s*$' $1 | cut -d : -f 1)"}
    )

    if (( $#line_numbers < 2 )); then
        echo 'build-index: cannot get YAML block for' $1 >&2
        return 1
    fi

    local -i m=$line_numbers[1]
    local -i n=$line_numbers[2]
    local -a block=()

    while (( $#line_numbers > 0 )); do
        # Pass `line_numbers` to `__get_lines`
        if ! line_numbers=( ${(f)"$(__get_lines $line_numbers)"} ); then
            # Only throw an error if a YAML block wasn't found on previous
            # iterations of the loop
            if (( $#block == 0 )); then
                echo 'build-index: cannot get YAML block for' $1 >&2
                return 1
            fi
        fi

        while (( $#line_numbers > 1 )); do
            # Pass `line_numbers` to `__check_lines`. If `check_lines` returns
            # `0`, then the first number in `line_numbers` really is the number
            # of a line that initiates a YAML block
            if line_numbers=( ${(f)"$(__check_lines $line_numbers)"} ); then
                break
            else
                # If `__check_lines` returns `1`, that could mean two things.
                # Either we've filtered `line_numbers` down to less than two
                # elements, in which case there must not be a valid YAML block,
                # or the first number in `line_numbers` is not really the
                # number of a line that initiates a YAML block, in which case
                # we need to pass `line_numbers` back to `__get_lines` to
                # filter `line_numbers` again until we have another possible
                # line number (if there is one) for a line initiating a YAML
                # block. Then, at the beginning of the next iteration of the
                # `while` loop, we pass `line_numbers` to `__check_lines`
                # again. We repeat this until there are less than two elements
                # left in `line_numbers` or we've found the number of a line
                # that initiates a YAML block.
                if (( $#line_numbers < 2 )); then
                    if (( $#block == 0 )); then
                        echo 'build-index: cannot get YAML block for' $1 >&2
                        return 1
                    fi
                else
                    line_numbers=( ${(f)"$(__get_lines $line_numbers)"} )
                fi
            fi
        done

        if (( $#line_numbers < 2 )); then
            line_numbers=( $line_numbers[2,-1] )
            break
        fi

        m=$line_numbers[1] # Line number of the start of the YAML block
        n=$line_numbers[2] # Line number of the end of the YAML block
        block+=( $file[m+1,n-1] )

        line_numbers=( $line_numbers[3,-1] )
    done

    # Cache `block` in an associative array
    blocks[$1]=${(j:++:)block}
}

# {{{1 Utility functions for `_parse_block`

# {{{2 __check_quotes()

__check_quotes() {
    if [[ $value[1] == "'" ]]; then
        single_quote=1
    elif [[ $value[1] == '"' ]]; then
        double_quote=1
    elif [[ $value[1] == '[' ]]; then
        bracket=1
    fi

    if [[ $value[-1] == "'" && $value[-2] == [^\'] ]]; then
        single_quote=0
    elif [[ $value[-1] == '"' && $value[-2] == [^\\] ]]; then
        double_quote=0
    elif [[ $value[-1] == "]" ]]; then
        bracket=0
    fi
}

# {{{2 __get_indent()

__get_indent() {
    echo ${#${1}%%[^[:space:]]*}
}

# {{{2 __append_to_array()

__append_to_array() {
    if [[ $value[1] == "'" ]]; then
        single_quote=1
    elif [[ $value[1] == '"' ]]; then
        double_quote=1
    elif [[ $value[1] == '[' ]]; then
        bracket=1
    fi

    values+=( $value )
}

# {{{2 __append_to_string()

__append_to_string() {
    if [[ -n $values[-1] ]]; then
        values[-1]="$values[-1] $value"
    else
        values[-1]=$value
    fi
}

# {{{2 __parse_dashed()

__parse_dashed() {
    trap "trap 'unset list_indent' EXIT" EXIT

    # If `list_indent` has not been defined, then this is the first list item.
    # Therefore, set `list_indent` to whatever the `line_indent` of this line
    # is.
    if [[ ! -n $list_indent ]]; then
        declare -gi list_indent=$line_indent
        value=${value##-[[:space:]]##}

        if [[ $value[1] == '[' ]]; then
            echo 'build-index: for key' $1 'in' $2',' \
                'list not allowed within list' >&2
            return 1
        fi

        __append_to_array

    elif (( line_indent < list_indent )); then
        echo 'build-index: for key' $1 'in' $2',' \
            'line outside scope of list' >&2
        return 1

    elif (( line_indent == list_indent )); then
        value=${value##-[[:space:]]##}

        if [[ $value[1] == '[' ]]; then
            echo 'build-index: for key' $1 'in' $2',' \
                'list not allowed within list' >&2
            return 1
        fi

        __append_to_array

    elif (( line_indent > list_indent )); then
        __append_to_string
    fi
}

# {{{2 __bracket_single_quotes()

__bracket_single_quotes() {
    value=${value//\'\'/++}

    if [[ $value[-1] == "'" ]]; then
        value=${value%\'}
        single_quote=0
    fi

    # Because the starting and ending quotes (if there were any on this line)
    # have been stripped, and because escaped quotes have been substituted with
    # something else, if there are any quotes left, that means either that
    # there's no closing quote or that there's an unescaped quote
    if [[ $value =~ "'" ]]; then
        if (( single_quote == 1 )); then
            echo 'build-index: for key' $1 'in' $2',' \
                'closing quote not found' >&2
            return 1
        elif (( single_quote == 0 )); then
            echo 'build-index: for key' $1 'in' $2',' \
                'unescaped single quotes found' >&2
            return 1
        fi
    fi

    value=${value//++/\'}
}

# {{{2 __bracket_double_quotes()

__bracket_double_quotes() {
    value=${value//\\\"/++}

    if [[ $value[-1] == '"' ]]; then
        value=${value%\"}
        double_quote=0
    fi

    # Because the starting and ending quotes (if there were any on this line)
    # have been stripped, and because escaped quotes have been substituted with
    # something else, if there are any quotes left, that means either that
    # there's no closing quote or that there's an unescaped quote
    if [[ $value =~ '"' ]]; then
        if (( double_quote == 1 )); then
            echo 'build-index: for key' $1 'in' $2',' \
                'closing quote not found' >&2
            return 1
        elif (( double_quote == 0 )); then
            echo 'build-index: for key' $1 'in' $2',' \
                'unescaped double quotes found' >&2
            return 1
        fi
    fi

    value=${value//++/\"}
}

# }}}2

# {{{1 _parse_block()

_parse_block() {
    # {{{2 Get values from first line

    # Find the line in the block with the key we're looking for; disregard
    # any lines before this
    local -a block=( ${(s:+:)blocks[$2]} )
    local -i first_line_num=$block[(I)[[:space:]]#$1:([[:space:]]##*)#]

    if (( $first_line_num > $#block )); then
        echo 'build-index: for key' $1 'in' $2',' \
            'key not found' >&2
        return 1
    fi

    # Get indent of the line containing the key; every subsequent line is going
    # to have to be indented at least as much as this line, unless it's part of
    # a properly quoted or bracketed string
    local -i key_indent=$(__get_indent $block[$first_line_num] )

    # Get value (if there is one) and trim whitespace from both ends
    local value=${block[$first_line_num]##[[:space:]]#${1}:([[:space:]]##)#}
    value=${value%%[[:space:]]#}
    local -a values
    values+=( $value )

    # If there is a value on the first line, do not parse subsequent lines
    # beginning with a '- ' as list items
    if [[ -n $value ]]; then
        local -i no_list=1
    else
        local -i no_list=0
    fi

    local -i single_quote=0
    local -i double_quote=0
    local -i bracket=0

__check_quotes

    # {{{2 Get values from subsequent lines

    local -a block_slice=( $block[(( $first_line_num + 1 )),-1] )
    local -i line_indent
    local line
    for line in $block_slice; do
        line_indent=$(__get_indent $line)

        # Trim whitespace from both ends
        value=${line#[[:space:]](#c$line_indent)}
        value=${value%%[[:space:]]#}

        if [[
            no_list -eq 0 &&
            (single_quote -eq 0) &&
            (double_quote -eq 0) &&
            (bracket -eq 0) &&
            $value[1,2] == '- '
        ]]; then

            if [[ $1 == title ]]; then
                echo 'build-index: for key' $1 'in' $2',' \
                    'list not allowed' >&2
                return 1

            elif (( line_indent < key_indent )); then
                echo 'build-index: for key' $1 'in' $2',' \
                    'line outside scope of key' >&2
                return 1

            elif (( line_indent == key_indent )); then
                __parse_dashed $1 $2 || return 1

            elif (( line_indent > key_indent )); then
                __parse_dashed $1 $2 || return 1
            fi

        else
            # If the string is quoted or bracketed, YAML disregards normal
            # indentation rules and always appends subsequent lines to the
            # current value
            if ((
                single_quote == 1 ||
                double_quote == 1 ||
                bracket == 1
            )); then
                __append_to_string || return 1

            elif (( line_indent < key_indent )); then
                echo 'build-index: for key' $1 'in' $2',' \
                    'line outside scope of key' >&2
                return 1

            elif (( line_indent == key_indent )); then
                # If the line has the same indentation as the key, then it
                # either has to be a list item beginning with '- ', which we've
                # already handled, or another key/value pair (in which case
                # we're done parsing)
                if [[ ! -n ${line##[^[\'][^:]#:*} ]]; then
                    break
                else
                    echo 'build-index: for key' $1 'in' $2',' \
                        'key/value pair expected' >&2
                    return 1
                fi

            elif (( line_indent > key_indent )); then
                if [[ -n $list_indent ]]; then
                    if (( line_indent > list_indent )); then
                        __append_to_string || return 1
                    else
                        echo 'build-index: for key' $1 'in' $2',' \
                            'line outside scope of list' >&2
                        return 1
                    fi

                else
                    __append_to_string || return 1
                    # If ever there is an indented line with a value before
                    # there is a list, no list can follow
                    no_list=1

                fi
            fi
        fi

        __check_quotes
    done

# {{{2 Process values

    single_quote=0
    double_quote=0

    # {{{3 Process values with brackets

    if [[ ${values[1][1]} == '[' ]]; then
        if [[ $1 == 'title' ]]; then
            echo 'build-index: for key' $1 'in' $2',' \
                'list not allowed' >&2
            return 1

        elif [[ ${values[-1][-1]} == ']' ]]; then
            value=${${values#'['}%']'}

        else
            echo 'build-index: for key' $1 'in' $2',' \
                'closing bracket not found' >&2
            return 1
        fi

        values=( ${(s:,:)value} )
        local -i index=1
        for value in $values; do
            value=${${value##[[:space:]]#}%%[[:space:]]#}

            if [[ $value[1,2] == '- ' ]]; then
                echo 'build-index: for key' $1 'in' $2',' \
                    'list not allowed within list' >&2
                return 1

            elif [[ $value[1] == "'" && $single_quote -eq 0 ]]; then
                single_quote=1
                value=${value#\'}
                __bracket_single_quotes $1 $2 || return 1

            elif (( single_quote == 1 )); then
                __bracket_single_quotes $1 $2 || return 1

            elif [[ $value[1] == '"' && $double_quote -eq 0 ]]; then
                double_quote=1
                value=${value#\"}
                __bracket_double_quotes $1 $2 || return 1

            elif (( double_quote == 1 )); then
                __bracket_double_quotes $1 $2 || return 1
            fi

            values[$index]=$value
            index=$(( index + 1 ))
        done

        if (( single_quote == 1 || double_quote == 1 )); then
            echo 'build-index: for key' $1 'in' $2',' \
                'closing quote not found' >&2
            return 1
        fi

    # {{{3 Process values with quotes
    else
        # Given the way that values have been collected, any value that starts
        # with a quote but does not end with a quote is breaking YAML parsing
        # rules. If there is both a starting and ending quote, strip off the
        # outside quotes and substitute properly escaped interior quotes with
        # '++'. Then, if any quotes remain, that means that there are unescaped
        # quotes.
        index=1
        for value in $values; do
            if [[ $value[1] == "'" ]]; then
                if [[ $value[-1] == "'" ]]; then
                    value=${${value#\'}%\'}
                    value=${value//\'\'/++}

                    if [[ $value =~ "'" ]]; then
                        echo 'build-index: for key' $1 'in' $2',' \
                            'unescaped single quotes found' >&2
                        return 1
                    fi

                    value=${value//++/\'}
                    values[$index]=$value

                else
                    echo 'build-index: for key' $1 'in' $2',' \
                        'closing quote not found' >&2
                    return 1
                fi

            elif [[ $value[1] == '"' ]]; then
                value=${value//\\\"/++}
                if [[ $value[-1] == '"' ]]; then
                    value=${${value#\"}%\"}

                    if [[ $value =~ '"' ]]; then
                        echo 'build-index: for key' $1 'in' $2',' \
                            'unescaped double quotes found' >&2
                        return 1
                    fi

                    value=${value//++/\"}
                    values[$index]=$value

                else
                    echo 'build-index: for key' $1 'in' $2',' \
                        'closing quote not found' >&2
                    return 1
                fi

            else
                # If the value isn't quoted, it can't start with a '@' or
                # contain a ':'
                if [[ $value[1] == '@' ]]; then
                    echo 'build-index: for key' $1 'in' $2',' \
                        "value begins with '@'" >&2
                    return 1
                elif [[ $value =~ ':' ]]; then
                    echo 'build-index: for key' $1 'in' $2',' \
                        'value contains nested key/value pair' >&2
                    return 1
                fi
            fi

            index=$(( index + 1 ))
        done
    fi

    # }}}3

    # Split keywords one more time at commas, like Pandoc's YAML parser does
    if [[ $1 == 'keywords' ]]; then
        values=( ${(s:,:)${(j:,:)values}} )
        index=1
        for value in $values; do
            value=${${value##[[:space:]]#}%%[[:space:]]#}
            values[$index]=$value
            index=$(( index + 1 ))
        done
    fi

    print -l -- ${values//[[:space:]]##/ }

# }}}2
}

# {{{1 Build an index file for every keyword found in notes

cd $HOME/Documents/Notes || exit 1

setopt extended_glob

declare -A blocks
declare -a file_keywords
declare -Ua all_keywords
declare -A keywords
declare -A titles

# Cache every file's metadata block, title, and keywords, and create a list of
# all keywords
declare file
for file in *.md; do
    _get_block $file
    file_keywords=( ${(f)"$(_parse_block keywords $file)"} )
    all_keywords+=( $file_keywords )
    keywords[$file]=${(j:++:)file_keywords}
    titles[$file]="$(_parse_block title $file)"
done

declare html_file
declare -a html_files=()
declare index_file
declare -a block
declare title
declare -a index_files
declare -Ua keyword_files
declare -a sub_index_files
declare sub_index_file
declare link
declare sub_keyword
declare -Ua sub_keyword_files
declare -a both_keyword_files
declare -Ua used_keyword_files
declare -Ua unused_keyword_files
declare ref
declare -a input_files=()
declare -a output_files=()

for keyword in $all_keywords; do
    html_file="$keyword index.html"
    html_files+=( $html_file )

    index_file=${keyword// /_}_index.md
    if [[ $keyword[1] == '@' ]]; then
        index_file=${index_file/@/_}
        title=${keyword/@/\\@}
    else
        title=$keyword
    fi

    # If the index file exists, use its existing metadata block; otherwise, use
    # a default metadata block
    if [[ -f $index_file ]]; then
        block=( '---' ${(s:++:)blocks[$index_file]} '---'$'\n' )
    else
        block=(
            '---'
            'id: '${index_file%.md}
            'title: '$title
            'keywords:'
            '---'$'\n'
        )
    fi

    # Before the index file is (re-)created, create a temporary copy of the
    # index file so that we can check later if there were any changes
    if [[ -f $index_file ]]; then
        cp $index_file /tmp/build_index.md
    else
        touch /tmp/build_index.md
    fi
    trap '[[ -f /tmp/build_index.md ]] && rm /tmp/build_index.md' EXIT

    print -lr -- $block > $index_file

    index_files+=( $index_file )

    # Create a list of all files that have the keyword `keyword`
    keyword_files=( ${(k)keywords[(R)*$keyword++*]} )
    keyword_files+=( ${(k)keywords[(R)*++$keyword*]} )
    keyword_files+=( ${(k)keywords[(R)$keyword]} )

    # Create a list of all index files that have the keyword `keyword`
    sub_index_files=( ${keyword_files:#[[:digit:]]*} )

    for sub_index_file in ${(i)sub_index_files}; do
        title=$titles[$sub_index_file]
        link='## ['$title']['$sub_index_file']'
        echo $link
        echo

        # Get the keyword corresponding to the sub-index file
        sub_keyword=${${sub_index_file%_index.md}//_/ }
        [[ $sub_keyword[1] == ' ' ]] && sub_keyword=${sub_keyword/ /@}

        # Create a list of all files that have the keyword `sub_keyword`
        sub_keyword_files=( ${(k)keywords[(R)*$sub_keyword++*]} )
        sub_keyword_files+=( ${(k)keywords[(R)*++$sub_keyword*]} )
        sub_keyword_files+=( ${(k)keywords[(R)$sub_keyword]} )

        # Create a list of all files that have both the keyword `keyword` and
        # the keyword `sub_keyword`
        both_keyword_files=( ${sub_keyword_files:*keyword_files} )
        both_keyword_files=( ${both_keyword_files:|sub_index_files} )

        for file in ${(nO)both_keyword_files}; do
            title=$titles[$file]
            link='['$title']['$file']'
            echo '*  ' $link
        done
        echo

        used_keyword_files+=( $both_keyword_files )
    done >> $index_file

    # Now that the loop is complete, append links to only those files that have
    # not already been linked to
    used_keyword_files+=( $sub_index_files )
    unused_keyword_files=( ${keyword_files:|used_keyword_files} )
    {
        for file in ${(nO)unused_keyword_files}; do
            title=$titles[$file]
            link='| ['$title']['$file']'
            echo $link
        done
        echo
    } >> $index_file

    # We have been using reference-style links, so add references
    for file in ${(o)keyword_files}; do
        ref=${file//_/%20}
        if [[ $ref[1,3] == '%20' ]]; then
            ref="@${ref#\%20}"
        fi
        ref="${ref%.md}.html"
        echo '['$file']:' $ref
    done >> $index_file

    used_keyword_files=()

    # Compare to temporary file; if they are different, add the index file to
    # the list of files to be converted to html by Pandoc
    if [[ -n "$(diff $index_file /tmp/build_index.md)" ]]; then
        input_files+=( $index_file )
        output_files+=( $html_file )
    fi
done

# Also convert index files to html
for input_file output_file in ${input_files:^output_files}; do
    pandoc -d notes -o $output_file $input_file
done

# Check if there are any index files that correspond to keywords that are no
# longer used
declare -a old_md_files=(
    ${(f)"$(comm -13 \
        =(print -l $index_files | sort) \
        =(print -l *index.md | sort))"}
)

declare -a old_html_files=(
    ${(f)"$(comm -13 \
        =(print -l $html_files | sort) \
        =(print -l *index.html | sort))"}
)

declare -a old_files=( $old_md_files $old_html_files )

if [[ -n $old_files ]]; then
    echo 'The following index files do not correspond to any keywords:'
    print -l ${(f)old_files}
fi

# }}}1
