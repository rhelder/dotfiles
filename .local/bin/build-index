#!/bin/zsh

# * Only allow '[' after key or after indent; in general, when there is a '[]'
#   expression, there will only be one element in `values`
# * Update comments

# {{{1 _build_index_rg()

_build_index_rg() {
    if [[ $3 ]]; then
        if [[ $1 == '-c' ]]; then
            echo $3 | rg --only-matching $1 $2
        else
            echo $3 | rg --only-matching $1 --replace $2
        fi
    else
        echo $2 | rg --only-matching $1
    fi
}

# {{{1 _build_index_get()

declare -A blocks

_build_index_get() {
    # {{{2 Get YAML block from file and store in array (only one block allowed)

    if [[ $blocks[$2] ]]; then
        block=( ${(s,:,)$blocks[$2]} )
    else
        local -a line_numbers
        line_numbers=( ${(f)"$(rg --line-number '^---$' $2 | cut -d : -f 1)"} )

        if (( $#line_numbers < 2 )); then
            echo 'build-index: cannot get YAML block for' $2 >&2
            return 1
        fi

        local -i block_end=$(( line_numbers[2] - 1 ))
        local -i block_length=$(( line_numbers[2] - line_numbers[1] - 1 ))
        declare -ga block
        block=( ${(f)"$(cat $2 | head -$block_end | tail -$block_length)"} )
    fi

    # {{{2 Get values from YAML metadata block

    local -i first_line_num=$block[(i)$1:*]
    local -a block_slice=( $block[$first_line_num,-1] )

    # Define search patterns for lines that contain an (unindented) key/value
    # pair, lines that start with a dash, and lines that start with
    # indentation.
    local kv_regex='^[^-:\s]+[^:]*:\s*(.*)$'
    local kv_regex_posix=${kv_regex/\\s/[:space:]}
    kv_regex_posix=${${kv_regex_posix//\\s/[[:space:]]}//[\(\)]/}
    local dash_regex='^\s*(-\s+(.+))$'
    local dash_regex_posix=${${dash_regex//\\s/[[:space:]]}//[\(\)]/}
    local indent_regex='^\s+([^-].*)$'
    local indent_regex_posix=${${indent_regex//\\s/[[:space:]]}//[\(\)]/}

    local -a values
    local value

    # Define flags:
    # * If `string` is equal to 1, then `value` is treated as a continuation of
    #   previous values corresponding to the same key (i.e., as a continuation
    #   of `metadata[$key]`).
    # * If `list` is equal to 1, then `value` is treated as a continuation of
    #   the most recent item in a list (i.e., as a continuation of the last
    #   member of a comma-separated list to which `metadata[$key]` expands).
    local -i cont=0
    local -i switch=0

    local line
    for line in $block_slice; do
        if [[ $line =~ $kv_regex_posix ]]; then
            if (( switch == 0 )); then
                values=( "$(_build_index_rg $kv_regex '$1' $line)" )

                # If there is a value on the same line as the key, subsequent
                # lines might be treated as a continuation of that value; so
                # set `string` to 1.
                [[ $values[-1] ]] && cont=1
                switch=1
            else
                break
            fi

        elif [[ $line =~ $dash_regex_posix ]]; then

            if (( cont == 0 )); then
                if [[ $1 == title ]]; then
                    unset values
                    return 1
                else
                    value="$(_build_index_rg $dash_regex '$2' $line)"
                    values+=( $value )
                fi
            else
                value="$(_build_index_rg $dash_regex '$1' $line)"
                values[-1]="$values[-1] $value"
            fi

        elif [[ $line =~ $indent_regex_posix ]]; then
            value="$(_build_index_rg $indent_regex '$1' $line)"

            if [[ $values[-1] ]]; then
                values[-1]="$values[-1] $value"
            else
                values[-1]=$value
            fi

            # Following an indented line, subsequent indented lines might be
            # treated as a continuation of `value`; so set string to 1.
            cont=1

        else
            unset values
            return 1
        fi
    done

    # {{{2 Process metadata values

    if [[ ! $values ]]; then
        echo 'build-index: no value found for key' $1 'in' $2 >&2
        return 1
    fi

    if [[ ${values[1][1]} == '[' ]]; then
        if [[ $1 = 'title' ]]; then
            unset values
            return 1
        else
            values=( ${(s:, :)${${values#'['}%']'}} )
        fi
    elif [[ $1 == 'keywords' ]]; then
        values=( ${(s:, :)${(j:, :)values}} )
    fi

    local -i start
    local -i single_quote=0
    local -i double_quote=0
    local -i index=1
    local -i next=1
    local quote="'"
    local dquote='"'

    for value in $values; do
        if (( single_quote == 0 )); then
            if [[ $value[1] == "'" && ! $double_quote -eq 1 ]]; then
                value=${value#\'}
                start=$index
                single_quote=1
            else
                value=${value//\'/++}
                values[$index]=$value
            fi
        fi

        if (( double_quote == 0 )); then
            if [[ $value[1] == '"' && ! $single_quote -eq 1 ]]; then
                value=${value#\"}
                start=$index
                double_quote=1
            else
                value=${value//\"/\=\=}
                values[$index]=$value
            fi
        fi

        if (( single_quote == 0 && double_quote == 0 )); then
            if [[ $value =~ '^@' ]]; then
                echo 'build-index: value in' $2 'begins with ''@''' >&2
                unset values
                return 1
            elif [[ $value =~ ':' ]]; then
                echo 'build-index: value in' $2 'contains nested mapping' >&2
                unset values
                return 1
            fi
        fi

        if (( single_quote == 1 )); then
            next=${values[(ib:index:)*$quote*]}
            if (( index != next )); then
                index=$(( index + 1 ))
                continue
            fi

            value=${value//\\\'/++}
            value=${value//\'\'/++}

            if [[ $value[-1] == "'" ]]; then
                value=${value%\'}
                single_quote=0
            fi

            if (( index == start )); then
                values[$index]=$value
            else
                unset "values[$index]"
                values[$index-1]="$values[$index-1] $value"
            fi

        elif (( double_quote == 1 )); then
            next=${values[(ib:index:)*${dquote}*]}
            if (( index != next )); then
                index=$(( index + 1 ))
                continue
            fi

            value=${value//\\\"/\=\=}

            if [[ $value[-1] == '"' ]]; then
                value=${value%\"}
                double_quote=0
            fi

            if (( index == start )); then
                values[$index]=$value
            else
                unset "values[$index]"
                values[$index-1]="$values[$index-1] $value"
            fi
        fi

        index=$(( index + 1 ))
    done

    if (( single_quote == 1 )); then
        echo 'build-index: ending quote not found' >&2
        return 1
    elif (( ${values[(i)*$quote*]} <= $#values )); then
        echo 'build-index: unescaped single quotes found' >&2
        return 1
    elif (( double_quote == 1 )); then
        echo 'build-index: ending quote not found' >&2
        return 1
    elif (( "${values[(i)*${dquote}*]}" <= $#values )); then
        echo 'build-index: unescaped double quotes found' >&2
        return 1
    else
        values=( ${values//++/\'} )
        values=( ${values//\=\=/\"} )
    fi

    # }}}2

    print -l $values
}

# {{{1 Build an index file for every keyword found in notes

cd $HOME/Documents/Notes || exit 1

setopt extended_glob

declare -T keywords_scalar keywords_array
declare -Ua all_keywords
declare -A keywords
declare -T block_scalar block

declare file
for file in *.md; do
    keywords_array=( ${(f)"$(_build_index_get keywords $file)"} )
    all_keywords+=( $keywords_array )
    keywords[$file]=$keywords_scalar
    blocks[$file]=$block_scalar
done

declare index_file
declare -a files
declare title
declare link

declare keyword
for keyword in $all_keywords; do
    index_file=${keyword:gs/ /_}_index.md

    if [[ -f $index_file ]]; then
        block=( '\-\-\-' ${(s.:.)$blocks[$index_file]} '\-\-\-\n' )
    else
        block=(
            '\-\-\-'
            'id: '${index_file%.md}
            'title: '$keyword
            'keywords: '
            '\-\-\-\n'
        )
    fi

    print -l $block > $index_file

    files=( ${(k)keywords[(R)(*$keyword:*)|(*:$keyword*)]} )

    for file in $files; do
        title="$(_build_index_get title $file)"
        link='['$title']['$file']'
        echo $link
    done | sort --ignore-case >> $index_file
done

# }}}1
