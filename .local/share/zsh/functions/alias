# Before aliasing, check whether or not name is already defined as a command,
# function, alias, etc. If not, let `alias` act as normal builtin `alias`.
#
# If you use this function, you might want to include a line in your `.zshrc`
# clearing the `zshrc_aliases` array before you define your aliases, so that
# the array doesn't grow arbitrarily large if you source your `.zshrc` multiple
# times in a shell session.

local flags=()
while getopts 'fgmsrL' flag; do
    case $flag in
        (f)     local force=1;;
        (g)     flags+=( -g );;
        (+g)    flags+=( +g );;
        (m)     local mopt=1; flags+=( -m );;
        (+m)    local mopt=1; flags+=( +m );;
        (s)     flags+=( -s );;
        (+s)    flags+=( +s );;
        (r)     flags+=( -r );;
        (+r)    flags+=( +r );;
        (L)     flags+=( -L );;
        (+L)    flags+=( +L );;
    esac
done
shift $(( OPTIND - 1 ))

# If no argument is provided, the `{+|-}m` flag is present, or the `-f` flag is
# present, run the `alias` builtin like normal
if [[ ! $* || $mopt -eq 1 || $force -eq 1 ]]; then
    builtin alias $flags $*

    # If `alias` was invoked in `.zshrc`, add arguments to `zshrc_aliases`
    # array, so that new alias names can be checked specifically against alias
    # names already used in `.zshrc`
    if [[ ${funcfiletrace[(r)/Users/rhelder/.config/zsh/.zshrc*]} ]]; then
        zshrc_aliases+=( $* )
    fi

else
    # Otherwise, check to see if there is another command, function, alias,
    # etc. by the same name before defining the alias
    local name
    local result
    for arg in $*; do
        name="${arg%%=*}"
        result=$(whence -v $name)

        # If the name is 'not found', define the alias as normal
        if [[ $result =~ "$name not found" ]]; then
            builtin alias $flags $arg

        else
            # If the result is an alias, only print an error message and return
            # if an alias by the same name has already been defined in
            # `.zshrc`. If it has, the name will be contained in a value in the
            # array `zshrc_aliases`, so reverse index this array. Otherwise,
            # `alias` will throw an error for every existing alias in `.zshrc`
            # whenever `.zshrc` is re-sourced, and it will refuse to redefine
            # existing aliases that the user is trying to change. This way, an
            # error only occurs if the user tries to use the same alias name
            # twice.
            if [[ $result =~ "$name is an alias" ]]; then
                if [[ ${zshrc_aliases[(r)$name=*]} ]]; then
                    echo $name 'already defined' >&2
                    return 1
                else
                    builtin alias $flags $arg
                fi

            else
                # If the result is anything other than an alias, print an error
                # message and return
                echo $name 'already defined' >&2
                return 1
            fi
        fi

        # If `alias` was invoked in `.zshrc`, add argument to `zshrc_aliases`
        # array
        if [[ ${funcfiletrace[(r)/Users/rhelder/.config/zsh/.zshrc*]} ]]; then
            zshrc_aliases+=( $arg )
        fi
    done
fi
